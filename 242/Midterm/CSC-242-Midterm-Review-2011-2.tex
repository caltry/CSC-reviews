% Author: David Larsen <dcl9934@cs.rit.edu>
\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{needspace}
\usepackage{color}
\usepackage{ifthen}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

\lstset{ %
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
tabsize=4,		                % sets default tabsize to 4 spaces
language=Python
}

\ifthenelse{\isundefined{\isAnswerKey}}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large}\color{white}}{}
}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large}\color{red}}{}
}


\author{Computer Science Community}
\title{CS-242 Midterm Exam Review \---- Winter 2011-2}

\begin{document}
\noindent{\Large CS-242 Midterm Exam Review \hfill Winter, 2011-2}

\begin{enumerate}
\section*{Stacks and Queues}
    \item What data structure is important for doing a depth-first traversal?

        \begin{answer}
        A stack.
        \end{answer}

    \item When traversing graphs last quarter, we didn't need to use either a
        stack or a queue. Why not?

        \begin{answer}
        We did depth-first traversals last quarter, when we did the pre, in and
        post-order tree traversals. We didn't need to maintain our own stack
        because our solutions were recursive: Python took care of maintaining
        the data at various stages of the traversal. Calling a function was
        like push()ing onto the stack and returning from a function was like
        pop()ing from the stack.
        \end{answer}

    \item If we wanted to implement a stack as a linked list, what linked-list
        operations would correspond to push() and pop()?

        \begin{answer}
        push( stack, element ) $\rightarrow$ insertFront( linked-list, element )\\
        pop( stack ) $\rightarrow$ removeFront( linked-list )
        \end{answer}

\section*{Graph Searching}
    \item If you want to find the shortest path to a node on a graph, what type
        of traversal would be best to use? Why?

        \begin{answer}
        A breadth-first traversal will {\em always} find a path with the
        minimum number of hops. This happens because we evaluate all of the
        nodes at the same distance away from the start point at the same time.
        We can say that the first time we see the node we want, we will have
        taken the shortest path to reach it.
        \end{answer}

    \item Show the principal data structure (stack or queue) for traversing the
        following graph and show the final path. When given the option to
        traverse multiple nodes, go in alphabetical order.

        \begin{tikzpicture}[-,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                            semithick]

        \node[state]            (A)                         {A};
        \node[state]            (B) [below left of=A]       {B};
        \node[state]            (C) [below of=A]            {C};
        \node[state]            (D) [below right of=A]       {D};
        \node[state]            (E) [below of=D]            {E};
        \node[state]            (F) [right of=D]            {F};

        \path   (A) edge node {} (B)
                    edge node {} (C)
                    edge node {} (D)
                (B) edge node {} (C)
                (C) edge node {} (E)
                (D) edge node {} (E)
                    edge node {} (F)
                (E) edge node {} (F);

        \end{tikzpicture}

        \begin{enumerate}
            \item\label{DFT} With a depth-first traversal from A to F:

                \begin{answer}
                \begin{tabular}{|c|}
                ~\\
                ~\\
                A\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{|c|}
                B\\
                C\\
                D\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{|c|}
                ~\\
                C\\
                D\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{|c|}
                ~\\
                E\\
                D\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{|c|}
                ~\\
                ~\\
                D\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{|c|}
                ~\\
                ~\\
                F\\\hline
                \end{tabular}
                Path: A $\rightarrow$ B $\rightarrow$ C $\rightarrow$ E
                $\rightarrow$ D $\rightarrow$ F.
                \end{answer}

            \item With a breadth-first traversal from A to F:

                \begin{answer}
                \begin{tabular}{c}
                \hline
                A\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{c}
                \hline
                BCD\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{c}
                \hline
                CD\\\hline
                \end{tabular}
                $\rightarrow$
                \begin{tabular}{c}
                \hline
                DE\\\hline
                \end{tabular}

                Path: A $\rightarrow$ D $\rightarrow$ E.
                \end{answer}

        \end{enumerate}

    \item When we traverse a graph, either depth-first or breadth-first, how do
        we keep track of the path to the goal state? That is, once we find a
        node, how do we find out what the path we took to get to it was?

        \begin{answer}
        We often use a dictionary that maps a node to the node that we came
        from to get to it. So, for \ref{DFT}, we would end up with a table like:
        \begin{tabular}{r|l}
        node & parent\\\hline
        F & D\\
        D & E\\
        C & A\\
        A & {\tt None}
        \end{tabular}

        To find the answer, we just follow each node to its parent until we
        reach {\tt None}.
        \end{answer}

\section*{Backtracking}
    \item The algorithm below is broken. Fix it.
    \begin{lstlisting}
        def solve(config):
          if not isGoal(config):
             return config
          else:
             for child in successors(config):
                solution = solve(child)
                if solution == None:
                   return solution
                return None
    \end{lstlisting}        
    \begin{answer}
    \begin{lstlisting}
        def solve(config):
          """solve: Config -> Config or NoneType"""
          if isGoal(config):
             return config
          else:
             for child in successors(config):
                if isValid(child):
                    solution = solve(child)
                    if solution != None:
                       return solution
             return None
    \end{lstlisting}
    \end{answer}
    
    \item
    \begin {enumerate}
        \item What functions need to be written for your corrected code above to run? 
            \begin{answer}
                \begin{enumerate}
                  \item isGoal( config )
                  \item sucessors( config )
                  \item isValid( config )
                \end{enumerate}
            \end{answer}
        \item What must these functions return?
            \begin{answer}
                \begin{enumerate}
                    \item isGoal( config ) returns a bool
                    \item sucessors( config ) returns a list of possible sucessor configurations
                    \item isvalid( config ) returns a bool
                \end{enumerate}
            \end{answer}
    \end{enumerate}
   
\end{enumerate}

\end{document}
