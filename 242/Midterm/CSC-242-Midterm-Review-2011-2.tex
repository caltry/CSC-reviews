% Author: David Larsen <dcl9934@cs.rit.edu>
\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{needspace}
\usepackage{color}
\usepackage{ifthen}

\lstset{ %
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
tabsize=4,		                % sets default tabsize to 4 spaces
language=Python
}

\ifthenelse{\isundefined{\isAnswerKey}}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large}\color{white}}{}
}
{
    \newenvironment{answer}{\large\lstset{basicstyle=\large}}{}
}


\author{Computer Science Community}
\title{CS-242 Midterm Exam Review \---- Winter 2011-2}

\begin{document}
\noindent{\Large CS-242 Midterm Exam Review \hfill Winter, 2011-2}

\begin{enumerate}
\section*{Stacks and Queues}
    \item What data structure is important for doing a depth-first traversal?

        \begin{answer}
        A stack.
        \end{answer}

    \item When traversing graphs last quarter, we didn't need to use either a
        stack or a queue. Why not?

        \begin{answer}
        We did depth-first traversals last quarter, when we did the pre, in and
        post-order tree traversals. We didn't need to maintain our own stack
        because our solutions were recursive: Python took care of maintaining
        the data at various stages of the traversal. Calling a function was
        like push()ing onto the stack and returning from a function was like
        pop()ing from the stack.
        \end{answer}

    \item If we wanted to implement a stack as a linked list, what linked-list
        operations would correspond to push() and pop()?

        \begin{answer}
        push( stack, element ) $\rightarrow$ insertFront( linked-list, element )\\
        pop( stack ) $\rightarrow$ removeFront( linked-list )
        \end{answer}

\section*{Graph Searching}
    \item If you want to ﬁnd the shortest path to a node on a graph, what type
        of traversal would be best to use? Why?

        \begin{answer}
        A breadth-first traversal will {\em always} find a path with the
        minimum number of hops. This happens because we evaluate all of the
        nodes at the same distance away from the start point at the same time.
        We can say that the first time we see the node we want, we will have
        taken the shortest path to reach it.
        \end{answer}

\section*{Backtracking}
    \item The algorithm below is broken. Fix it.
    \begin{lstlisting}
        def solve(config):
          if not isGoal(config):
             return config
          else:
             for child in successors(config):
                solution = solve(child)
                if solution == None:
                   return solution
                return None
    \end{lstlisting}        
    \begin{answer}
    \begin{lstlisting}
        def solve(config):
          """solve: Config -> Config or NoneType"""
          if isGoal(config):
             return config
          else:
             for child in successors(config):
                if isValid(child):
                    solution = solve(child)
                    if solution != None:
                       return solution
             return None
    \end{lstlisting}
    \end{answer}
    
    \item
    \begin {enumerate}
        \item What functions need to be written for your corrected code above to run? 
            \begin{answer}
                \begin{enumerate}
                  \item isGoal( config )
                  \item sucessors( config )
                  \item isValid( config )
                \end{enumerate}
            \end{answer}
        \item What must these functions return?
            \begin{answer}
                \begin{enumerate}
                    \item isGoal( config ) returns a bool
                    \item sucessors( config ) returns a list of possible sucessor configurations
                    \item isvalid( config ) returns a bool
                \end{enumerate}
            \end{answer}
    \end{enumerate}
   
\end{enumerate}

\end{document}
